<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TG-43 Brachytherapy Dose Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-card: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --accent-primary: #ff5722;
            --accent-hover: #f4511e;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Montserrat', sans-serif;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .calculator-section, .visualization-section {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .visualization-container {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-card);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            background: var(--bg-card);
            touch-action: none;
        }

        .control-panel {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-primary);
        }

        select, input {
            width: 100%;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-card);
            border-radius: 8px;
        }

        .toggle-button {
            padding: 8px 16px;
            background: var(--accent-primary);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }

        .toggle-button:hover {
            background: var(--accent-hover);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="calculator-section">
            <h2>TG-43 Dose Calculator</h2>
            
            <div class="control-panel">
                <div class="form-group">
                    <label for="source-type">Source Type:</label>
                    <select id="source-type">
                        <option value="AgX100">AgX100</option>
                        <option value="IR192HDR">IR-192 HDR</option>
                        <option value="Cs131">Cs-131</option>
                        <option value="I125_6711">I-125 (Model 6711)</option>
                        <option value="Pd103_2335">Pd-103 (Model 200)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="activity">Activity (mCi):</label>
                    <input type="number" id="activity" min="0" step="0.1" value="1.0">
                </div>

                <button id="toggle-isodose" class="toggle-button">Toggle Isodose Lines</button>
            </div>

            <div class="results">
                <h3>Calculation Results:</h3>
                <p id="calculation-results">Select a point on the diagram to calculate dose.</p>
            </div>
        </div>

        <div class="visualization-section">
            <h2>Source Visualization</h2>
            <div class="visualization-container">
                <canvas id="sourceCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
 class TG43Calculator {
            constructor(canvas) {
                this.canvas = canvas;
                this.setupCanvas();
                this.bindEvents();
                this.calcPoint = { x: 200, y: 200 };
                this.isDragging = false;
                this.showIsodose = false;
                this.sourceType = 'AgX100';
                this.sourceData = null;
                
                // Debug log
                console.log('Calculator initialized');
            }

            async initialize() {
                try {
                    const constantsText = await window.fs.readFile('data/source_constants.csv', { encoding: 'utf8' });
                    const constants = await this.parseCSV(constantsText);
                    this.sourceData = {};

                    // Load initial source data
                    const initialSource = constants[0];
                    this.sourceData[initialSource.source_type] = {
                        doseRateConstant: parseFloat(initialSource.dose_rate_constant),
                        activeLength: parseFloat(initialSource.active_length)
                    };

                    console.log('Initial data loaded:', this.sourceData);
                    this.draw(); // Initial draw after data is loaded
                } catch (error) {
                    console.error('Error loading source data:', error);
                    // Still do initial draw even if data loading fails
                    this.draw();
                }
            }

            async parseCSV(csvText) {
                return new Promise((resolve) => {
                    Papa.parse(csvText, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: (results) => resolve(results.data)
                    });
                });
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientWidth; // Square aspect ratio
                this.ctx = this.canvas.getContext('2d');
                this.scale = this.canvas.width / 400;
                
                console.log('Canvas setup:', {
                    width: this.canvas.width,
                    height: this.canvas.height,
                    scale: this.scale
                });
            }

    async loadRadialDoseData(sourceType) {
        try {
            const response = await window.fs.readFile(`data/brachy/${sourceType}_radial_dose.csv`, { encoding: 'utf8' });
            return await this.parseCSV(response);
        } catch (error) {
            console.error(`Error loading radial dose data for ${sourceType}:`, error);
            return [];
        }
    }

    async loadAnisotropyData(sourceType) {
        try {
            const response = await window.fs.readFile(`data/brachy/${sourceType}_anisotropy.csv`, { encoding: 'utf8' });
            return await this.parseCSV(response);
        } catch (error) {
            console.error(`Error loading anisotropy data for ${sourceType}:`, error);
            return [];
        }
    }

    interpolateRadialDose(r) {
        const sourceData = this.sourceData[this.sourceType];
        const data = sourceData.radialDoseData;
        
        // Sort by radius
        const sortedData = [...data].sort((a, b) => a.radius_cm - b.radius_cm);
        
        // Find bracketing points
        let lower = sortedData[0];
        let upper = sortedData[sortedData.length - 1];
        
        for (let i = 0; i < sortedData.length - 1; i++) {
            if (sortedData[i].radius_cm <= r && sortedData[i + 1].radius_cm >= r) {
                lower = sortedData[i];
                upper = sortedData[i + 1];
                break;
            }
        }

        // Linear interpolation
        const ratio = (r - lower.radius_cm) / (upper.radius_cm - lower.radius_cm);
        return lower.g_r + (upper.g_r - lower.g_r) * ratio;
    }

    interpolateAnisotropy(r, theta) {
        const sourceData = this.sourceData[this.sourceType];
        const data = sourceData.anisotropyData;
        
        // Find closest radius data points
        const uniqueRadii = [...new Set(data.map(d => d.radius_cm))].sort((a, b) => a - b);
        let rLower = uniqueRadii[0];
        let rUpper = uniqueRadii[uniqueRadii.length - 1];
        
        for (let i = 0; i < uniqueRadii.length - 1; i++) {
            if (uniqueRadii[i] <= r && uniqueRadii[i + 1] >= r) {
                rLower = uniqueRadii[i];
                rUpper = uniqueRadii[i + 1];
                break;
            }
        }

        // Get data for both radii
        const lowerRadiusData = data.filter(d => d.radius_cm === rLower);
        const upperRadiusData = data.filter(d => d.radius_cm === rUpper);

        // Interpolate for each radius
        const lowerValue = this.interpolateAngle(lowerRadiusData, theta);
        const upperValue = this.interpolateAngle(upperRadiusData, theta);

        // Interpolate between radii
        const rRatio = (r - rLower) / (rUpper - rLower);
        return lowerValue + (upperValue - lowerValue) * rRatio;
    }

    interpolateAngle(radiusData, theta) {
        // Sort by angle
        const sortedData = [...radiusData].sort((a, b) => a.angle_deg - b.angle_deg);
        
        // Find bracketing angles
        let lower = sortedData[0];
        let upper = sortedData[sortedData.length - 1];
        
        for (let i = 0; i < sortedData.length - 1; i++) {
            if (sortedData[i].angle_deg <= theta && sortedData[i + 1].angle_deg >= theta) {
                lower = sortedData[i];
                upper = sortedData[i + 1];
                break;
            }
        }

        // Linear interpolation
        const ratio = (theta - lower.angle_deg) / (upper.angle_deg - lower.angle_deg);
        return lower.F_r_theta + (upper.F_r_theta - lower.F_r_theta) * ratio;
    }

    calculateDose() {
                const sourceCenter = { 
                    x: this.canvas.width / 2, 
                    y: this.canvas.height / 2 
                };
                
                const r = Math.sqrt(
                    Math.pow(this.calcPoint.x - sourceCenter.x, 2) +
                    Math.pow(this.calcPoint.y - sourceCenter.y, 2)
                ) * 0.1; // Convert pixels to cm

                const theta = Math.atan2(
                    this.calcPoint.y - sourceCenter.y,
                    this.calcPoint.x - sourceCenter.x
                ) * (180 / Math.PI);

                const activity = parseFloat(document.getElementById('activity').value);
                let dose = activity * (1 / (r * r)); // Simple inverse square for now

                // If we have source data, use it
                if (this.sourceData && this.sourceData[this.sourceType]) {
                    dose *= this.sourceData[this.sourceType].doseRateConstant;
                }

                document.getElementById('calculation-results').innerHTML = `
                    <strong>Distance (r):</strong> ${r.toFixed(2)} cm<br>
                    <strong>Angle (θ):</strong> ${theta.toFixed(1)}°<br>
                    <strong>Dose Rate:</strong> ${dose.toFixed(3)} cGy/h
                `;
            }
            // Add these methods to your TG43Calculator class

bindEvents() {
    // Mouse events
    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
    window.addEventListener('resize', this.handleResize.bind(this));
    
    // Touch events for mobile
    this.canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        this.handleMouseDown({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
    });
    
    this.canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        this.handleMouseMove({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
    });
    
    this.canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        this.handleMouseUp();
    });

    console.log('Events bound successfully');
}

handleMouseDown(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
    this.isDragging = true;
    this.calcPoint = { x, y };
    this.calculateDose();
    this.draw();
    
    console.log('Mouse down:', { x, y });
}

handleMouseMove(e) {
    if (!this.isDragging) return;
    const rect = this.canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
    this.calcPoint = { x, y };
    this.calculateDose();
    this.draw();
}

handleMouseUp() {
    this.isDragging = false;
}

handleResize() {
    this.setupCanvas();
    this.draw();
}

drawSource() {
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    this.ctx.save();
    this.ctx.translate(centerX, centerY);
    
    // Draw source capsule
    this.ctx.fillStyle = '#ffff00';
    this.ctx.strokeStyle = '#ff8800';
    this.ctx.lineWidth = 2;
    
    // Scale the source size based on canvas
    const scaleRatio = this.canvas.width / 400;
    const capsuleWidth = 20 * scaleRatio;
    const capsuleHeight = 10 * scaleRatio;
    
    this.ctx.beginPath();
    this.ctx.ellipse(0, 0, capsuleWidth, capsuleHeight, 0, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    this.ctx.restore();
}

drawCalcPoint() {
    this.ctx.beginPath();
    this.ctx.arc(this.calcPoint.x, this.calcPoint.y, 5, 0, Math.PI * 2);
    this.ctx.fillStyle = '#ff5722';
    this.ctx.fill();
    this.ctx.strokeStyle = 'white';
    this.ctx.stroke();
}

drawIsodoseLines() {
    if (!this.showIsodose) return;

    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const doses = [200, 150, 100, 50, 25, 10];
    const colors = ['#ff0000', '#ff4400', '#ff8800', '#ffbb00', '#ffee00', '#ffffaa'];

    doses.forEach((dose, i) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = colors[i];
        this.ctx.lineWidth = 1;

        for (let angle = 0; angle < 360; angle += 5) {
            const r = Math.sqrt(100 / dose) * 50 * this.scale;
            const x = centerX + r * Math.cos(angle * Math.PI / 180);
            const y = centerY + r * Math.sin(angle * Math.PI / 180);

            if (angle === 0) {
                this.ctx.moveTo(x, y);
            } else {
                this.ctx.lineTo(x, y);
            }
        }

        this.ctx.closePath();
        this.ctx.stroke();
    });
}

draw() {
    if (!this.ctx) {
        console.error('No context available');
        return;
    }

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    if (this.showIsodose) {
        this.drawIsodoseLines();
    }
    this.drawSource();
    this.drawCalcPoint();
    
    console.log('Draw complete');
}

draw() {
                if (!this.ctx) {
                    console.error('No context available');
                    return;
                }

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.showIsodose) {
                    this.drawIsodoseLines();
                }
                this.drawSource();
                this.drawCalcPoint();
                
                console.log('Draw complete');
            }
        }

        // Initialize calculator when DOM is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            const canvas = document.getElementById('sourceCanvas');
            const calculator = new TG43Calculator(canvas);
            await calculator.initialize();

            // Event listeners
            document.getElementById('source-type').addEventListener('change', (e) => {
                calculator.sourceType = e.target.value;
                calculator.calculateDose();
                calculator.draw();
            });

            document.getElementById('activity').addEventListener('input', () => {
                calculator.calculateDose();
                calculator.draw();
            });

            document.getElementById('toggle-isodose').addEventListener('click', () => {
                calculator.showIsodose = !calculator.showIsodose;
                calculator.draw();
            });
        });
    </script>
</body>
</html>