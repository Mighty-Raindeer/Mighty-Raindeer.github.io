<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dose Calculation Algorithm Comparison | FPB vs AAA vs Acuros</title>
    <meta name="description" content="Interactive comparison of radiation dose calculation algorithms: Finite Pencil Beam, AAA, and Acuros XB. Understand accuracy in heterogeneous media.">
    
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #242424;
            --bg-card: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --accent-primary: #ff5722;
            --accent-hover: #f4511e;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Montserrat', sans-serif;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 10px;
        }

        .intro {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 30px;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }

        .algorithm-tabs {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .tab-button {
            padding: 10px 20px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .tab-button:hover {
            background: var(--bg-card);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .comparison-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .visualization-panel {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .visualization-panel h2 {
            color: var(--accent-primary);
            margin-top: 0;
            font-size: 1.2rem;
        }

        .dose-comparison {
            position: relative;
            width: 100%;
            height: 400px;
            background: var(--bg-card);
            border-radius: 4px;
            overflow: hidden;
        }

        .scenario-selector {
            margin-bottom: 15px;
        }

        .scenario-selector select {
            width: 100%;
            padding: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .slider-container {
            margin-top: 15px;
        }

        .comparison-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            background: var(--bg-card);
            outline: none;
            border-radius: 3px;
        }

        .comparison-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .algorithm-info {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .algorithm-details {
            display: none;
        }

        .algorithm-details.active {
            display: block;
        }

        .algorithm-details h2 {
            color: var(--accent-primary);
            margin-top: 0;
        }

        .physics-box {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            border-left: 3px solid var(--accent-primary);
        }

        .physics-box h3 {
            margin-top: 0;
            color: var(--accent-primary);
        }

        .accuracy-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .accuracy-table th,
        .accuracy-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .accuracy-table th {
            background: var(--bg-card);
            color: var(--accent-primary);
        }

        .accuracy-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .accuracy-high {
            background: #4caf50;
        }

        .accuracy-medium {
            background: #ff9800;
        }

        .accuracy-low {
            background: #f44336;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .equation {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
        }

        .limitation-list {
            list-style: none;
            padding-left: 0;
        }

        .limitation-list li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
            color: var(--text-secondary);
        }

        .limitation-list li::before {
            content: '⚠';
            position: absolute;
            left: 0;
            color: #ff9800;
        }

        @media (max-width: 768px) {
            .comparison-layout {
                grid-template-columns: 1fr;
            }
            
            .algorithm-tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dose Calculation Algorithm Comparison</h1>
        <p class="intro">
            Modern treatment planning systems use different dose calculation algorithms with varying levels 
            of accuracy and computational complexity. Understanding their differences is crucial for 
            optimal treatment planning, especially in heterogeneous media.
        </p>

        <div class="algorithm-tabs">
            <button class="tab-button active" data-algorithm="fpb">Finite Pencil Beam</button>
            <button class="tab-button" data-algorithm="aaa">AAA (Anisotropic Analytical Algorithm)</button>
            <button class="tab-button" data-algorithm="acuros">Acuros XB</button>
        </div>

        <div class="comparison-layout">
            <div class="visualization-panel">
                <h2>Dose Distribution Comparison</h2>
                <div class="scenario-selector">
                    <select id="scenario-select">
                        <option value="water">Homogeneous Water Phantom</option>
                        <option value="lung">Lung/Soft Tissue Interface</option>
                        <option value="bone">Bone/Tissue Interface</option>
                        <option value="air">Air Cavity (Head & Neck)</option>
                        <option value="prosthesis">Metal Prosthesis</option>
                    </select>
                </div>
                <div class="dose-comparison">
                    <canvas id="dose-canvas"></canvas>
                </div>
                <div class="slider-container">
                    <input type="range" class="comparison-slider" id="depth-slider" min="0" max="30" value="10">
                    <div class="slider-labels">
                        <span>0 cm</span>
                        <span>Depth: <span id="depth-value">10</span> cm</span>
                        <span>30 cm</span>
                    </div>
                </div>
            </div>

            <div class="visualization-panel">
                <h2>Lateral Profile Comparison</h2>
                <div class="dose-comparison">
                    <canvas id="profile-canvas"></canvas>
                </div>
                <div class="slider-container">
                    <input type="range" class="comparison-slider" id="field-slider" min="2" max="20" value="10">
                    <div class="slider-labels">
                        <span>2x2 cm²</span>
                        <span>Field: <span id="field-value">10</span>x<span id="field-value2">10</span> cm²</span>
                        <span>20x20 cm²</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="algorithm-info">
            <!-- Finite Pencil Beam Details -->
            <div class="algorithm-details active" id="fpb-details">
                <h2>Finite Pencil Beam (FPB) Algorithm</h2>
                
                <div class="physics-box">
                    <h3>Physical Principle</h3>
                    <p>FPB decomposes the broad beam into multiple narrow pencil beams. Each pencil beam's dose contribution 
                    is calculated using pre-computed kernels derived from Monte Carlo simulations in water. The algorithm 
                    applies density scaling for heterogeneity corrections.</p>
                    
                    <div class="equation">
                        D(x,y,z) = ∑∑ K(x-x',y-y',z) × Φ(x',y') × CF(ρ)
                    </div>
                    <p>Where K is the pencil beam kernel, Φ is the fluence, and CF is the density correction factor.</p>
                </div>

                <table class="accuracy-table">
                    <thead>
                        <tr>
                            <th>Clinical Scenario</th>
                            <th>Accuracy</th>
                            <th>Deviation from Monte Carlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Homogeneous water/tissue</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Lung (low density)</td>
                            <td><span class="accuracy-indicator accuracy-low"></span>Poor</td>
                            <td>5-15%</td>
                        </tr>
                        <tr>
                            <td>Bone interfaces</td>
                            <td><span class="accuracy-indicator accuracy-medium"></span>Moderate</td>
                            <td>3-5%</td>
                        </tr>
                        <tr>
                            <td>Small fields (&lt;3x3 cm²)</td>
                            <td><span class="accuracy-indicator accuracy-low"></span>Poor</td>
                            <td>5-10%</td>
                        </tr>
                        <tr>
                            <td>Air cavities</td>
                            <td><span class="accuracy-indicator accuracy-low"></span>Poor</td>
                            <td>5-20%</td>
                        </tr>
                    </tbody>
                </table>

                <div class="physics-box">
                    <h3>Key Limitations</h3>
                    <ul class="limitation-list">
                        <li>Assumes rectilinear particle transport (no lateral scatter modeling)</li>
                        <li>Simple density scaling inadequate for low-density media</li>
                        <li>Cannot account for electron transport at interfaces</li>
                        <li>Inaccurate for small fields due to lack of lateral equilibrium</li>
                        <li>No modeling of neutron dose for high-energy beams (&gt;10 MV)</li>
                    </ul>
                </div>

                <div class="physics-box">
                    <h3>Clinical Applications</h3>
                    <p><strong>Best suited for:</strong></p>
                    <ul>
                        <li>Conventional 3D-CRT in homogeneous regions</li>
                        <li>Breast treatments (relatively homogeneous)</li>
                        <li>Brain treatments (minimal heterogeneity)</li>
                        <li>Large field sizes (&gt;5x5 cm²)</li>
                    </ul>
                    <p><strong>Avoid for:</strong></p>
                    <ul>
                        <li>Lung SBRT/SABR</li>
                        <li>Head and neck with air cavities</li>
                        <li>Small field dosimetry</li>
                        <li>Treatments near metal implants</li>
                    </ul>
                </div>
            </div>

            <!-- AAA Details -->
            <div class="algorithm-details" id="aaa-details">
                <h2>Anisotropic Analytical Algorithm (AAA)</h2>
                
                <div class="physics-box">
                    <h3>Physical Principle</h3>
                    <p>AAA uses separate modeling of primary photons, scattered photons, and contamination electrons. 
                    It employs Monte Carlo-derived energy deposition kernels that are scaled anisotropically based on 
                    radiological path length in different directions.</p>
                    
                    <div class="equation">
                        D(r) = ∫∫∫ Ψ(r') × K(r-r',ρ) × A(θ,φ) dV'
                    </div>
                    <p>Where Ψ is the energy fluence, K is the anisotropic kernel, and A accounts for angular dependencies.</p>
                </div>

                <table class="accuracy-table">
                    <thead>
                        <tr>
                            <th>Clinical Scenario</th>
                            <th>Accuracy</th>
                            <th>Deviation from Monte Carlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Homogeneous water/tissue</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Lung (low density)</td>
                            <td><span class="accuracy-indicator accuracy-medium"></span>Good</td>
                            <td>2-5%</td>
                        </tr>
                        <tr>
                            <td>Bone interfaces</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Good</td>
                            <td>2-3%</td>
                        </tr>
                        <tr>
                            <td>Small fields (&lt;3x3 cm²)</td>
                            <td><span class="accuracy-indicator accuracy-medium"></span>Moderate</td>
                            <td>3-5%</td>
                        </tr>
                        <tr>
                            <td>Air cavities</td>
                            <td><span class="accuracy-indicator accuracy-medium"></span>Moderate</td>
                            <td>3-7%</td>
                        </tr>
                    </tbody>
                </table>

                <div class="physics-box">
                    <h3>Key Advantages over FPB</h3>
                    <ul>
                        <li>Anisotropic scaling accounts for lateral heterogeneities</li>
                        <li>Better modeling of secondary electron transport</li>
                        <li>Improved accuracy in lung and air cavities</li>
                        <li>Separate modeling of scatter components</li>
                        <li>More accurate for IMRT/VMAT optimization</li>
                    </ul>
                </div>

                <div class="physics-box">
                    <h3>Clinical Applications</h3>
                    <p><strong>Best suited for:</strong></p>
                    <ul>
                        <li>IMRT/VMAT planning</li>
                        <li>Lung treatments (non-SBRT)</li>
                        <li>Head and neck treatments</li>
                        <li>Prostate and pelvis</li>
                    </ul>
                    <p><strong>Limitations:</strong></p>
                    <ul>
                        <li>Still uses kernel-based approximations</li>
                        <li>Limited accuracy near high-Z materials</li>
                        <li>May overestimate dose beyond low-density regions</li>
                        <li>Calculation time increases with heterogeneity</li>
                    </ul>
                </div>
            </div>

            <!-- Acuros Details -->
            <div class="algorithm-details" id="acuros-details">
                <h2>Acuros XB (External Beam)</h2>
                
                <div class="physics-box">
                    <h3>Physical Principle</h3>
                    <p>Acuros XB solves the Linear Boltzmann Transport Equation (LBTE) deterministically using the 
                    grid-based Boltzmann solver method. It explicitly models the transport of photons and electrons 
                    through matter without using kernel approximations.</p>
                    
                    <div class="equation">
                        Ω·∇ψ + σ_t ψ = ∫∫ σ_s(E'→E,Ω'→Ω) ψ dE'dΩ' + S
                    </div>
                    <p>Where ψ is the angular flux, σ_t is total cross-section, σ_s is scattering cross-section, and S is the source.</p>
                </div>

                <table class="accuracy-table">
                    <thead>
                        <tr>
                            <th>Clinical Scenario</th>
                            <th>Accuracy</th>
                            <th>Deviation from Monte Carlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Homogeneous water/tissue</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 1%</td>
                        </tr>
                        <tr>
                            <td>Lung (low density)</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Bone interfaces</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Small fields (&lt;3x3 cm²)</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Air cavities</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Excellent</td>
                            <td>&lt; 2%</td>
                        </tr>
                        <tr>
                            <td>Metal implants</td>
                            <td><span class="accuracy-indicator accuracy-high"></span>Very Good</td>
                            <td>2-3%</td>
                        </tr>
                    </tbody>
                </table>

                <div class="physics-box">
                    <h3>Key Advantages</h3>
                    <ul>
                        <li>Direct solution of radiation transport equation</li>
                        <li>Explicit modeling of all particle interactions</li>
                        <li>Accurate in all heterogeneous conditions</li>
                        <li>Models electron transport explicitly</li>
                        <li>Can report dose to medium or dose to water</li>
                        <li>Comparable accuracy to Monte Carlo with faster computation</li>
                    </ul>
                </div>

                <div class="physics-box">
                    <h3>Clinical Applications</h3>
                    <p><strong>Recommended for:</strong></p>
                    <ul>
                        <li>Lung SBRT/SABR treatments</li>
                        <li>Small field dosimetry</li>
                        <li>Treatments near metal implants</li>
                        <li>Head and neck with air cavities</li>
                        <li>Any treatment requiring highest accuracy</li>
                    </ul>
                    <p><strong>Considerations:</strong></p>
                    <ul>
                        <li>Longer calculation time than AAA (but still clinically practical)</li>
                        <li>Choice between dose-to-medium vs dose-to-water reporting</li>
                        <li>May require different MU for same prescription vs AAA</li>
                        <li>Excellent for plan QA and verification</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AlgorithmComparison {
            constructor() {
                this.currentAlgorithm = 'fpb';
                this.currentScenario = 'water';
                this.doseCanvas = document.getElementById('dose-canvas');
                this.profileCanvas = document.getElementById('profile-canvas');
                this.doseCtx = this.doseCanvas.getContext('2d');
                this.profileCtx = this.profileCanvas.getContext('2d');
                
                this.setupCanvases();
                this.bindEvents();
                this.drawComparisons();
            }

            setupCanvases() {
                const setupCanvas = (canvas) => {
                    const rect = canvas.parentElement.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                };
                
                setupCanvas(this.doseCanvas);
                setupCanvas(this.profileCanvas);
            }

            bindEvents() {
                // Algorithm tabs
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        this.currentAlgorithm = btn.dataset.algorithm;
                        
                        // Update details
                        document.querySelectorAll('.algorithm-details').forEach(detail => {
                            detail.classList.remove('active');
                        });
                        document.getElementById(`${this.currentAlgorithm}-details`).classList.add('active');
                        
                        this.drawComparisons();
                    });
                });

                // Scenario selector
                document.getElementById('scenario-select').addEventListener('change', (e) => {
                    this.currentScenario = e.target.value;
                    this.drawComparisons();
                });

                // Depth slider
                document.getElementById('depth-slider').addEventListener('input', (e) => {
                    document.getElementById('depth-value').textContent = e.target.value;
                    this.drawDoseComparison();
                });

                // Field size slider
                document.getElementById('field-slider').addEventListener('input', (e) => {
                    const size = e.target.value;
                    document.getElementById('field-value').textContent = size;
                    document.getElementById('field-value2').textContent = size;
                    this.drawProfileComparison();
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvases();
                    this.drawComparisons();
                });
            }

            drawComparisons() {
                this.drawDoseComparison();
                this.drawProfileComparison();
            }

            drawDoseComparison() {
                const ctx = this.doseCtx;
                const width = this.doseCanvas.width;
                const height = this.doseCanvas.height;
                const depth = parseFloat(document.getElementById('depth-slider').value);
                
                // Clear canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // Draw heterogeneity representation
                this.drawHeterogeneity(ctx, width, height);
                
                // Draw PDD curves for each algorithm
                const algorithms = {
                    'fpb': { color: '#ff5722', label: 'FPB' },
                    'aaa': { color: '#2196f3', label: 'AAA' },
                    'acuros': { color: '#4caf50', label: 'Acuros' }
                };
                
                const centerY = height / 2;
                const startX = 50;
                const endX = width - 50;
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(startX, 20);
                ctx.lineTo(startX, height - 20);
                ctx.moveTo(startX, centerY);
                ctx.lineTo(endX, centerY);
                ctx.stroke();
                
                // Draw PDD curves
                Object.entries(algorithms).forEach(([algo, config]) => {
                    ctx.strokeStyle = config.color;
                    ctx.lineWidth = algo === this.currentAlgorithm ? 3 : 2;
                    ctx.globalAlpha = algo === this.currentAlgorithm ? 1.0 : 0.5;
                    
                    ctx.beginPath();
                    for (let x = startX; x <= endX; x += 2) {
                        const relX = (x - startX) / (endX - startX);
                        const dose = this.calculateDose(algo, relX * 30, depth);
                        const y = centerY - dose * (centerY - 30);
                        
                        if (x === startX) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                });
                
                // Draw legend
                let legendY = 30;
                Object.entries(algorithms).forEach(([algo, config]) => {
                    ctx.fillStyle = config.color;
                    ctx.fillRect(width - 100, legendY, 20, 10);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(config.label, width - 70, legendY + 8);
                    legendY += 20;
                });
                
                // Add labels
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText('0', startX - 20, centerY + 5);
                ctx.fillText('30 cm', endX - 20, centerY + 20);
                ctx.fillText('100%', startX - 35, 35);
                ctx.fillText('Depth', (startX + endX) / 2 - 20, height - 5);
            }

            drawProfileComparison() {
                const ctx = this.profileCtx;
                const width = this.profileCanvas.width;
                const height = this.profileCanvas.height;
                const fieldSize = parseFloat(document.getElementById('field-slider').value);
                
                // Clear canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                const centerX = width / 2;
                const centerY = height / 2;
                const profileWidth = width - 100;
                
                // Draw axes
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX, 20);
                ctx.lineTo(centerX, height - 20);
                ctx.moveTo(50, centerY);
                ctx.lineTo(width - 50, centerY);
                ctx.stroke();
                
                // Draw profiles for each algorithm
                const algorithms = {
                    'fpb': { color: '#ff5722', label: 'FPB' },
                    'aaa': { color: '#2196f3', label: 'AAA' },
                    'acuros': { color: '#4caf50', label: 'Acuros' }
                };
                
                Object.entries(algorithms).forEach(([algo, config]) => {
                    ctx.strokeStyle = config.color;
                    ctx.lineWidth = algo === this.currentAlgorithm ? 3 : 2;
                    ctx.globalAlpha = algo === this.currentAlgorithm ? 1.0 : 0.5;
                    
                    ctx.beginPath();
                    for (let x = 50; x <= width - 50; x += 2) {
                        const offAxis = ((x - centerX) / profileWidth) * 40; // cm from central axis
                        const profile = this.calculateProfile(algo, offAxis, fieldSize);
                        const y = centerY - profile * (centerY - 30);
                        
                        if (x === 50) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                });
                
                // Draw field edges
                const fieldEdgePixels = (fieldSize / 40) * profileWidth;
                ctx.strokeStyle = 'rgba(255, 87, 34, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(centerX - fieldEdgePixels, 20);
                ctx.lineTo(centerX - fieldEdgePixels, height - 20);
                ctx.moveTo(centerX + fieldEdgePixels, 20);
                ctx.lineTo(centerX + fieldEdgePixels, height - 20);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText('Off-axis distance (cm)', centerX - 50, height - 5);
                ctx.fillText('Relative Dose (%)', 10, 15);
            }

            drawHeterogeneity(ctx, width, height) {
                // Draw tissue layers based on scenario
                const layers = this.getScenarioLayers();
                const layerHeight = height / layers.length;
                
                layers.forEach((layer, index) => {
                    ctx.fillStyle = layer.color;
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(0, index * layerHeight, width, layerHeight);
                    
                    // Label
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.fillText(layer.name, 5, index * layerHeight + 15);
                });
            }

            getScenarioLayers() {
                const scenarios = {
                    'water': [
                        { name: 'Water', color: '#2196f3' },
                        { name: 'Water', color: '#2196f3' },
                        { name: 'Water', color: '#2196f3' }
                    ],
                    'lung': [
                        { name: 'Tissue', color: '#ff9800' },
                        { name: 'Lung', color: '#81c784' },
                        { name: 'Tissue', color: '#ff9800' }
                    ],
                    'bone': [
                        { name: 'Tissue', color: '#ff9800' },
                        { name: 'Bone', color: '#e0e0e0' },
                        { name: 'Tissue', color: '#ff9800' }
                    ],
                    'air': [
                        { name: 'Tissue', color: '#ff9800' },
                        { name: 'Air', color: '#424242' },
                        { name: 'Tissue', color: '#ff9800' }
                    ],
                    'prosthesis': [
                        { name: 'Tissue', color: '#ff9800' },
                        { name: 'Metal', color: '#9e9e9e' },
                        { name: 'Tissue', color: '#ff9800' }
                    ]
                };
                
                return scenarios[this.currentScenario] || scenarios['water'];
            }

            calculateDose(algorithm, x, depth) {
                // Simplified dose calculations for visualization
                let baseDose = Math.exp(-x * 0.05) * (1 - depth * 0.01);
                
                // Apply algorithm-specific modifications based on scenario
                if (this.currentScenario === 'lung') {
                    if (algorithm === 'fpb') {
                        baseDose *= 0.85; // FPB underestimates in lung
                    } else if (algorithm === 'aaa') {
                        baseDose *= 0.95;
                    }
                } else if (this.currentScenario === 'air') {
                    if (algorithm === 'fpb') {
                        baseDose *= 0.80; // Significant underestimation
                    } else if (algorithm === 'aaa') {
                        baseDose *= 0.93;
                    }
                }
                
                return Math.max(0, Math.min(1, baseDose));
            }

            calculateProfile(algorithm, offAxis, fieldSize) {
                // Simplified profile calculation
                const sigma = fieldSize / 3;
                let profile = Math.exp(-(offAxis * offAxis) / (2 * sigma * sigma));
                
                // Add penumbra modeling differences
                if (Math.abs(offAxis) > fieldSize / 2) {
                    const penumbraWidth = algorithm === 'fpb' ? 5 : 
                                         algorithm === 'aaa' ? 4 : 3;
                    const distance = Math.abs(offAxis) - fieldSize / 2;
                    profile *= Math.exp(-distance / penumbraWidth);
                }
                
                return profile;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AlgorithmComparison();
        });
    </script>
</body>
</html>